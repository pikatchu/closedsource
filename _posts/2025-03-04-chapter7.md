---
title: Games
layout: post
order: 7
---
![Lacrosse](/assets/images/lacrosse.png)

Jasmina and Leo were caught off guard on Saturday morning. They had expected to do their usual chores, but Martin greeted them with a grin.  

"Not today," he said. "It’s the weekend. We play games."  

Curious, they followed him outside. The monastery grounds looked different—livelier. Groups of teenagers were spread across the fields, engaged in various competitive games. Some were wrestling on tatamis, others were racing, and a few were playing what looked like a futuristic version of chess.  

Martin led them toward a large field where a fast-paced game was underway. Players dashed across the field, wielding lacrosse sticks, but with one major difference—each player was controlling drones.  

"This is drone lacrosse," Martin explained. "It’s a great way to train your drone skills. See how they use their drones to block opponents, catch the ball, and even pass? They can even lift themselves off the ground for a short time."  

As he spoke, one of the players stepped onto his drone and soared a few feet into the air to intercept a pass.  

"But," Martin added with a smirk, "you don’t want to go too high. If someone knocks your drone out while you're in the air... well, let’s just say the landing isn’t fun."  

Jasmina and Leo watched in fascination as the game played out. The speed, the strategy, the mix of physical skill and drone control—it was unlike anything they had seen before.  

When the match ended, a group of players jogged toward them. Leading them was a tall, athletic boy with short, dark hair.  

"Sebastian," Martin introduced him. "He’s fifteen, one of the best lacrosse players here."  

Sebastian flashed a confident grin. "You guys never seen a drone game before?"  

Leo shook his head, still trying to process what he had just watched.  

Sebastian nodded knowingly. "They’re huge among Companions. We train for international tournaments. Best players from every Companion faction go head-to-head."  

Jasmina and Leo exchanged a glance. The idea of an international tournament for something like this was incredible.  

Sebastian twirled his lacrosse stick. "Wanna try?"  

Leo hesitated, but before he could say anything, Jasmina stepped forward. "Sure!"  

Sebastian’s grin widened. "Alright, let me show you the basics."  

He handed her a stick and guided her through the movements—how to hold it, how to scoop and throw the ball, and most importantly, how to use the drones to assist.  

Leo watched closely, feeling both nervous and excited.

A few more teenagers arrived on the field, drawn by the excitement of the game. Sebastian waved them over.  

"Hey, we’ve got two newcomers," he announced. "Jasmina and Leo. They’ve never played before, so let’s keep it light and improvise a quick match."  

Leo took a step back. "Uh, I think I’ll just watch—"  

Before he could finish, Jasmina grabbed his arm. "I only play if you play," she said with a teasing grin.  

Leo sighed. "Jasmina—"  

She didn’t let go. "Come on, it’ll be fun."  

Sebastian clapped him on the shoulder. "Yeah, don’t overthink it. Just run around, mess with your drone. You’ll get the hang of it."  

Reluctantly, Leo gave in. "Fine."  

The game began, and at first, both Leo and Jasmina ran awkwardly across the field, trying their best to keep up. They swung their lacrosse sticks wildly, missing more passes than they caught. Their drones buzzed unpredictably, sometimes reacting too late, other times drifting aimlessly.  

The others laughed good-naturedly but kept passing them the ball, encouraging them to keep trying.  

Sebastian called a quick break and jogged over to Leo. "Here, let me show you something."  

He demonstrated a simple move, extending his hand forward in a smooth motion. His drone shot forward and nudged the ball precisely where he wanted it to go. "Try it."  

Leo mimicked the motion. His drone zipped forward in response.  

Sebastian’s expression shifted from friendly enthusiasm to complete confusion.  

"Wait…" he muttered, staring at Leo. "That’s not your drone. That’s mine."  

Leo blinked. "What?"  

"You just moved my drone," Sebastian said slowly. "How did you do that? Did you hack into it?"  

Jasmina’s eyes widened. "Leo… is that true?"  

Before he could answer, the other teenagers ran over, intrigued by the conversation.  

"Try mine!" one of them said, holding up his hands. "Can you control mine?"  

Leo hesitated, then made a similar gesture. The drone responded.  

The group let out a collective gasp.  

Sebastian shook his head in disbelief. "No way. That’s insane."  

Leo started to feel a rush of excitement. For once, the attention was on him, and not because he was in trouble. Grinning, he lifted both hands and made an upward motion.  

Every drone on the field lifted off at once.  

The murmurs of shock turned into outright amazement. The crowd around him grew as more players and onlookers gathered.  

Jasmina was beaming. "That’s awesome, Leo!"  

Encouraged, Leo gestured again, commanding the drones to form patterns in the sky—circles, waves, synchronized movements that looked almost like a dance. The teenagers stared up in awe, laughing and cheering.  

For the first time in a long while, Leo felt powerful.  

Then, as he lowered his hands and let the drones return to their original owners, he turned back toward Martin.  

Standing just behind him, watching from a distance, was the Rector.  

His expression was unreadable, but there was no mistaking the tension in his posture.  

Without a word, the Rector turned and walked away.Martin led Leo through the quiet halls of the monastery, his steps measured, his expression unreadable. When they reached the heavy wooden doors of the Rector’s office, Martin stopped and turned to him.  

"Wait here," he said before stepping inside.  

Leo stood in silence, but the voices from within were unmistakable. Tense words cut through the thick wood, sharp and unrelenting. Though he couldn’t make out every word, he knew exactly what—or rather, who—they were arguing about.  

A moment later, the door opened, and Martin gestured for him to enter.  

Inside, Elias stood near the Rector’s desk, arms crossed, his face set in a hard line. The Rector sat behind his desk, his expression carefully neutral. Across from him stood another man—older, dressed in the robes of a Catonian scholar. His stance was rigid, his eyes never landing directly on Leo.  

"This cannot be allowed," the man said firmly. "An implanted individual living among us? It is against everything we stand for."  

The Rector’s tone remained measured. "Brother Bernardo, our duty is also to offer refuge to our fellow Companions."  

Bernardo’s lips pressed into a thin line. "Companions?" He motioned toward Leo. "How do we know that? How do we know this isn’t an Inquisitor’s ploy?"  

Elias shifted, his posture tense, but the Rector raised a hand, keeping the conversation from escalating.  

Then, after a brief silence, he said, "He is the son of the Commander in Chief."  

Bernardo’s reaction was immediate. His shoulders went rigid, his breath catching for the briefest moment. He finally glanced at Leo—just for an instant—before turning back to the Rector.  

"That," he said carefully, "is not widely known, I assume."  

"No," the Rector replied. "And it must remain that way, for his safety."  

Bernardo exhaled, his expression dark. He took a step back, considering his next words carefully.  

"I have lost too many brothers and sisters fighting men with implants," he said finally. "AI, implants, all of it—it always ends the same way. You know that as well as I do." His voice was quiet, but resolute. "This time will be no different."  

Without waiting for a response, he turned and left, closing the door firmly behind him.  

The silence stretched for a moment before the Rector turned to Leo.  

"Forgive Brother Bernardo," he said. "He has seen firsthand what the Inquisition’s technology has done to our people."  

Leo didn’t answer.  

The Rector’s expression remained composed, but his voice carried a quiet weight. "That said, he is not wrong about one thing. You were told to stay unnoticed. Drawing attention to yourself in such a manner was careless."  

Elias finally spoke, his tone controlled but heavy with disapproval. "You understand how dangerous this could have been?"  

Leo answered. "I didn’t think—"  

"No, you didn’t," the Rector interrupted. "That cannot happen again."  

---

Joaquim led Leo and Jasmina into the classroom filled with older students focused on their screens. The steady tapping of keyboards filled the room. He gestured toward two empty seats.

"I don’t have time to run a separate lesson for you," he said. "So you’ll sit with the older students and work on your own. If you have questions, ask Sebastian."

Sebastian walked over, dropping into the seat next to them. "Alright, let’s get started."

Joaquim continued, "Today, you’re going to learn about automata. These are simple machines that process sequences of symbols, moving between different states based on what they read. Automata are used everywhere in computing—text processing, data validation, even artificial intelligence."

Jasmina and Leo leaned in.

Sebastian took over. "An automaton is a system with rules. It starts in one state, reads characters one by one, and based on what it sees, it moves to the next state or stays where it is. Each state is represented by a label in our assembly program, and transitions happen when we compare the current character to something we’re looking for."

Leo thought for a moment. "So it’s like a flowchart?"

"Exactly," Joaquim said. "And today, you’re going to write an automaton that checks if a string is a valid email. The simplified version we’ll start with has two states—first, we look for an `@`, and if we find it, we move to the next state, where we look for a `.`."

Sebastian pulled up the program.

`http://closedsourcebook.com/asm_automaton.html`

Sebastian pointed to the first part. "This program starts by looking for an `@` symbol. It reads each character, prints it to the screen, and checks if it’s an `@`. If it finds one, it moves to the `find_dot` state."

Jasmina followed along. "And if it doesn’t find an `@`, it keeps looping through `find_at`, right?"

"Exactly," Sebastian said. "If it reaches the end of the string without finding `@`, it jumps to `invalid`, printing `F` for false."

Leo traced the next part of the program. "And if it finds `@`, it moves to `find_dot`, where it does the same thing but now searching for a `.`?"

Sebastian nodded. "Right. If we find a `.` before the end of the string, we go to `valid` and print `T` for true. Otherwise, if we hit the end of the string first, we jump to `invalid`."

Joaquim stepped in. "This is the fundamental idea behind automata. You move through states based on conditions. Right now, this automaton has only two states, but more complex ones can have many more."

Jasmina leaned forward. "So if we wanted to make it more advanced, we could add more states to check other rules—like making sure there’s something before and after `@`?"

"Exactly," Sebastian said. "But first, try this version out. Make sure you understand every step before we make it more complex."
Joaquim stepped forward, looking at the fascinated expressions on Jasmina and Leo’s faces. "Now that you understand how an automaton works, let me introduce you to a more compact and convenient way of representing them—a language that programmers use all the time. They’re called regular expressions."

Jasmina and Leo exchanged a glance. 

Joaquim continued, "A regular expression is a way to describe an automaton without manually writing out the states and transitions like we just did. Instead of constructing the automaton step by step, we write a single expression that captures the same logic. It might seem abstract at first, but once you get used to it, it’s an incredibly powerful tool."

He turned to the board and wrote:

```
ab
```

"This is our first basic rule: concatenation. This means that ‘b’ must come directly after ‘a.’ Simple, right?"

Jasmina nodded. "Like writing a word—one letter follows another."

"Exactly," Joaquim said. "Now let’s introduce another operation: union." He wrote:

```
a(b|c)
```

"This means that we start with ‘a,’ and after that, we can have either ‘b’ or ‘c.’ The vertical bar `|` means ‘or.’ So this expression matches either ‘ab’ or ‘ac.’"

Leo’s eyes lit up. "So it's like a branching path in the automaton."

"Precisely," Joaquim said. "Now, the last essential operation—the star." He wrote:

```
a*
```

"This means that ‘a’ can appear zero or more times. It could match an empty string, ‘a,’ ‘aa,’ ‘aaa,’ and so on, endlessly."

Jasmina leaned in. "So it’s like a loop?"

"Exactly. And these three operations—concatenation, union, and the star—are all you need to define any regular expression. They are the building blocks of everything else."

Joaquim then turned to the class. "Of course, for convenience, we have other symbols that simplify things. For example, `+` is similar to `*`, except it means ‘one or more’ instead of ‘zero or more.’ The `?` means ‘zero or one’—it makes something optional. There are also ways to express negation, character ranges, and more. But everything can ultimately be expressed using just the three fundamental operations."

He gave a few more examples, showing how more complex patterns could be constructed from these simple building blocks. 

"Now," Joaquim said, "here’s something very important to remember: regular expressions and automata are two sides of the same coin. Every automaton can be written as a regular expression, and every regular expression can be turned into an automaton. In fact, when computers process regular expressions, they first convert them into an automaton behind the scenes, just like the one we wrote earlier. Then they use a program—very similar to what you just implemented—to run the automaton and match patterns."

Leo’s eyes widened. "So every time we search for something in a text file using a regular expression, there’s an automaton running in the background?"

"That’s exactly right," Joaquim confirmed. "Now, let’s put this into practice. We’re going to write a regular expression that matches an email address—just like our automaton did."Joaquim turned back to the board and wrote:  

```
[^@]+@[^.]+[.].+
```

"Alright," he said, turning to Leo and Jasmina, "let’s break this down piece by piece. This is a simplified regular expression that checks whether a string looks like an email address. Now, before we begin, I want to make something very clear—this is **not** the real regular expression used to validate email addresses. Email formats are actually more complex than they seem, but for now, this will give you a good idea of how regular expressions work."  

He pointed to the first part:  

```
[^@]+
```

"This part might look strange at first, but let’s break it down. The square brackets `[ ]` define what is called a **character class**—a set of characters that are allowed. The `^` at the beginning of the brackets means **negation**. So `[^@]` means ‘any character **except** @.’ The `+` means ‘one or more times,’ so this entire piece ensures that we start with at least **one or more characters that are not an @**."

Jasmina nodded. "So this is making sure that we don’t start the email with @?"

"Exactly," Joaquim said. "Now, let’s move on." He underlined the next part:

```
@
```

"This part is simple. It just says we expect the @ symbol to be there at this exact position."

Leo smirked. "If it wasn’t there, then it wouldn’t be an email."

"Correct. Now, let’s look at the next section."

```
[^.]+
```

"This follows the same pattern as before. The `[^.]` means ‘any character **except** a period (.)’, and the `+` means ‘one or more times.’ So, this ensures that after the @, we have at least one or more characters that **aren’t** a dot."

"So this is the domain name?" Jasmina asked.

"Right, this ensures that we have something like `catonian` in `leo@catonian.net` rather than an email like `leo@.net`, which wouldn’t be valid. Now, let’s move to the next part."

```
[.]
```

"Here, we just have a **literal dot** inside square brackets. That means the next character **must** be a dot (`.`), just like the `@` earlier."

Leo tilted his head. "Why put it inside brackets if it’s just a dot?"

"Good question. Normally, a `.` in a regular expression means ‘any character.’ But we don’t want that—we want to **match an actual dot**. So we put it inside brackets to make sure it’s treated as a literal character."

He pointed to the final part:

```
.+
```

"This last part is simple. The `.` means ‘any character’ and the `+` means ‘one or more times.’ This ensures that **after** the dot, there’s at least one more character. That way, we don’t allow emails like `leo@catonian.` which would be missing a proper domain ending."

Jasmina exhaled. "So this makes sure there’s at least something like `.com`, `.net`, or `.org` at the end."

"Exactly," Joaquim said. "Now, remember, this is just a simplified version. A **real** email validation regular expression is much more complex and accounts for many edge cases. But this should give you an idea of how powerful regular expressions can be."

Leo grinned. "I see why programmers like these. It’s a much shorter way to describe an automaton."

"That’s right," Joaquim said. "And now, let’s test this expression in practice."
`http://closedsourcebook.com/regexp.html`.

Joaquim leaned against the desk, arms crossed, as he watched the class absorb his lesson. “Regular expressions,” he continued, “are something you’ll use all the time. Whether it’s searching for patterns, validating inputs, or parsing text, they’re everywhere.”

A boy sitting a few rows behind Leo and Jasmina smirked. “Yeah, perfect for validating matching parentheses,” he said with a mischievous grin.

Joaquim sighed, half amused, half exasperated. “Well, Erling,” he said, eyeing the boy, “I wasn’t planning to get into that today, but since you brought it up…”

At that moment, the drone hovering behind Joaquim echoed in a monotone voice, “Since you brought it up.”

Erling’s grin widened. Joaquim narrowed his eyes. “Erling, did you hack into the school’s system again?”

The boy shrugged, unbothered. “I mean, if the school actually updated their software once in a while, it wouldn’t be so easy.”

Joaquim shook his head. “Alright, fair enough. We’ll update it. But let’s get back on track. You see, regular expressions are powerful, but they have limits.”

Jasmina looked intrigued. “Like what?”

Joaquim paced in front of the class. “Let’s say I want to check if a string has properly balanced parentheses or brackets—meaning every `(` has a matching `)`, and every `[` has a matching `]`. Sounds simple, right?” He paused, letting the question hang. “Well, regular expressions can’t do that.”

Leo frowned. “But… why not? Can’t we just write a pattern that says, ‘match any `(` and then make sure there’s a `)` later’?”

Joaquim smiled. “That’s a reasonable assumption. In fact, let’s take a different approach. You now know that every regular expression has an equivalent automaton. So if a regular expression could match balanced parentheses, then we should be able to write an automaton for it, right?”

Jasmina nodded. “Okay… so what would the automaton look like?”

Joaquim raised a finger. “Let’s think through the states. We start in an initial state. If we read an opening `(`, what happens?”

Jasmina thought for a moment. “We go into a new state. Same thing if we see `[`. But if we see `)` or `]` first, that’s an error, right?”

“Exactly!” Joaquim nodded. “Now, let’s think about what happens as we continue reading the string. Suppose the first character was `(`—what should we do when we encounter the second character?”

Leo hesitated. “We have to match the whole sequence, and then at the end, make sure there’s a closing `)`.”

Joaquim smiled. “Right. And how would we express that in an automaton?”

Leo and Jasmina exchanged a look. After a moment, Jasmina said, “Wait… we can’t.”

Joaquim snapped his fingers. “Exactly! You can’t express it with a standard automaton because you need memory. You need to *remember* every `(` or `[` that you see, and you need to check that when you close one, you’re closing the right one.”

He moved to the board and drew a rough sketch of a stack. “This is where stacks come in. Think of it like a pile of books. When you encounter an opening `(` or `[`, you *push* it onto the stack. Then, when you encounter a closing `)` or `]`, you *pop* the last thing from the stack and check if it matches. If the stack is empty at the end, the string is valid. If not, it’s invalid.”

Joaquim turned back to them. “That’s why you can’t match balanced parentheses with regular expressions alone. You need a stack.”

Leo’s eyes widened in understanding. “So a stack keeps track of what we need to close?”

“Exactly,” Joaquim said. “Now, let’s take a look at the assembly program that actually does this.”

Joaquim gestured toward the screen. “You can find the source code here: http://closedsourcebook.com/asm_stack.html,” he said, letting the class take it in. 

“Now, don’t be intimidated by the size of the code,” he continued. “It might look complex at first, but if you break it down, you’ll see it’s really just an automaton like before. The only difference is that instead of jumping from one state to another immediately, we’re interacting with the stack every time we process a character.”

He pointed at the first part of the program. “Like before, we have states. But now, the key operations are *push* and *pop*. When we encounter an opening `(` or `[`, we push it onto the stack. That means we’re keeping track of what needs to be closed later. If we see a closing `)` or `]`, we pop the last thing from the stack and check if it matches. If it does, we continue. If not, we stop with an error.”

Joaquim let the words sink in. “That’s all it is. A systematic way of ensuring that every opening bracket has a matching closing bracket. If the stack is empty at the end, the input is valid. If it’s not—then something went wrong.”

Jasmina leaned in, scanning the code. “So every time we process a character, we’re checking the stack?”

“Exactly,” Joaquim said. “And once you understand that, the rest is just details.” 

Leo nodded slowly. “Okay… I think I get it.”

Joaquim smiled. “Good. Because once you understand stacks, you’re well on your way to understanding recursion, function calls, and how programming languages actually work under the hood. But one step at a time.”

Joaquim turned back to the board, gesturing toward the example they had just worked through. "Now," he said, "let's talk about something important. Up until now, we've been managing our own stack in memory—storing values, moving a register to keep track of it, and loading and storing data manually. But the processor has a **built-in stack** specifically designed for this."

Leo and Jasmina leaned in, intrigued.

"This built-in stack," Joaquim continued, "is called the **execution stack**. The processor uses it internally, and we can also take advantage of it. Instead of manually managing a stack with memory addresses, we use two special instructions: **PUSH** and **POP**. These instructions let us push values onto the stack and retrieve them later, just like we did before, but now the processor handles the details."

He pointed at a new section of code on the screen. "We've updated our program to use this native stack instead of managing our own. Every time we **PUSH**, the processor stores a value at the top of the stack and moves the stack pointer down. When we **POP**, it retrieves the last stored value and moves the stack pointer back up. The register that tracks the stack’s position is called **SP**, or 'Stack Pointer'. You can actually see its value changing in the emulator when you step through the code."

Jasmina’s eyes lit up. "So it’s doing the same thing, but in a more efficient way?"

"Exactly," Joaquim said. "Under the hood, it's still just memory—just like our manually managed stack. But this special memory region is predefined, and the processor gives us fast, easy-to-use instructions to work with it."

Leo was already looking at the emulator screen. "So every time I push something, SP decreases?"

"That's right," Joaquim confirmed. "And when you pop, SP increases again. This stack is used for more than just storing data—you'll soon learn that it plays a critical role in **function calls** as well. But we’ll get to that later."

He tapped a command on his console, and a new example appeared. "You can check out the revised version of our program here: **http://closedsourcebook.com/asm_native_stack.html**. Run it step by step and pay close attention to how SP moves. That’s the key to understanding how the processor's native stack works."

Leo and Jasmina exchanged a glance, excited to try it out.