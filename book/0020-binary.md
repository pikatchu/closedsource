Mr. Lee leaned back, stretching his arms. "What we just did, Leo, was create a number system in base 3."  

Leo tilted his head. "Base?"  

Mr. Lee nodded. "The number of symbols in your encoding is called the base of the system. In our case, we had three symbols—¶, §, and ‡—so we were working in base 3."  

He tapped the paper. "And the symbols themselves? Those are called digits. But you probably knew that."  

Leo nodded slightly.  

"Now, in practice, we don't usually invent new symbols like we just did," Mr. Lee continued. "It's hard to remember too many strange characters, so it's tradition to reuse well-known digits as much as possible. We start with 0, 1, 2… and when we run out of numbers, we use letters."  

Leo raised an eyebrow. "Letters?"  

"Yes. Let's say we had a base bigger than 10. We'd use 0 through 9 as usual, but once we run out, we start using letters. So, in base 11, the number after 9 would be ‘A', in base 12 it would be ‘B', and so on."  

Leo frowned. "Wait… greater than 10? People actually use bases bigger than 10?"  

Mr. Lee smirked. "Oh yes. And one in particular is going to be very important to you: base 16."  

Leo repeated the words in his head. Base 16.  

"Any programmer has to know it," Mr. Lee continued. "It's called hexadecimal. And trust me, you'll get very familiar with it soon enough."  

Leo was still trying to process this when another question popped into his head. "But why would anyone use a different base? I mean, 10 works fine, doesn't it?"  

Mr. Lee leaned forward. "Machines don't use base 10, Leo. They don't count like we do."  

Leo narrowed his eyes. "Then how do they count?"  

"With electricity," Mr. Lee said simply. "Think about it. A machine doesn't have fingers. It doesn't have a brain like ours. What it does have is electricity—signals turning on and off. And the simplest way to count using electricity is to represent numbers with just two states: no signal and signal. Off and on. Zero and one."  

He tapped the table.  

"And that, Leo, is why everything in a computer is binary."  

Leo sat in silence, digesting the idea.  

"Now, you might be wondering—if machines count in binary, why do programmers care about hexadecimal?"  

Leo nodded. That was exactly what he was wondering.  

Mr. Lee pulled out another sheet of paper.  

"Binary numbers are long, and they're hard for humans to read. Look at this:"  

He wrote:  

`1111111111111111`  

"It's difficult to tell at a glance what this number is, right?"  

Leo squinted. It was just a long mess of ones.  

Mr. Lee continued. "But what if we regroup the digits into groups of four?"  

He added spaces, separating them into chunks:  

`1111 1111 1111 1111`  

"Better?"  

Leo nodded. It was starting to look more structured.  

"Now," Mr. Lee said, "instead of writing these four-digit chunks in binary, we write them in hexadecimal. Each group of four binary digits can be represented by just one hexadecimal digit."  

He quickly scribbled below the binary:  

`FFFF`  

Leo's eyebrows lifted.  

"Now tell me, which one is easier to read—`1111111111111111`, or `FFFF`?"  

Leo exhaled. "FFFF, obviously."  

Mr. Lee grinned. "And that's why programmers use hexadecimal. It's a shortcut for writing binary. Machines still use binary underneath, but for humans, `FFFF` is a lot easier to read and write than a long string of ones and zeroes."  

Leo nodded slowly, staring at the paper.  

Mr. Lee continued, his voice calm but firm. "The first thing you need to do is become comfortable with these numbers. Because when you program, you'll need to understand the encoding used. Otherwise, you'll never truly know what your code is doing."  

Leo exhaled. "So I have to learn how to think in base 2?"  

Mr. Lee smiled. "Exactly. And once you do, you'll see the world differently."
